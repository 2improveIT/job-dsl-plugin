package javaposse.jobdsl.dsl.helpers

import com.google.common.base.Preconditions
import javaposse.jobdsl.dsl.JobParent
import javaposse.jobdsl.dsl.WithXmlAction

class MavenHelper extends AbstractHelper {

    Map<String, Object> jobArguments

    boolean rootPOMAdded = false
    boolean goalsAdded = false
    boolean mavenOptsAdded = false
    boolean perModuleEmailAdded = false
    boolean archivingDisabledAdded = false
    boolean runHeadlessAdded = false
    boolean ignoreUpstreamChangesAdded = false

    MavenHelper(List<WithXmlAction> withXmlActions, Map<String, Object> jobArguments = [:]) {
        super(withXmlActions)
        this.jobArguments = jobArguments
    }

    /**
     * Specifies the path to the root POM.
     * @param rootPOMArg path to the root POM
     */
    def rootPOM(String rootPOMArg) {
        Preconditions.checkState(jobArguments['type'] == JobParent.maven, "rootPOM can only be applied for Maven jobs")
        Preconditions.checkState(!rootPOMAdded, "rootPOM can only be applied once")
        rootPOMAdded = true
        execute {
            def node = methodMissing('rootPOM', rootPOMArg)
            it / node
        }
    }

    /**
     * Specifies the goals to execute.
     * @param goalsArg the goals to execute
     */
    def goals(String goalsArg) {
        Preconditions.checkState(jobArguments['type'] == JobParent.maven, "goals can only be applied for Maven jobs")
        Preconditions.checkState(!goalsAdded, "goals can only be applied once")
        goalsAdded = true
        execute {
            def node = methodMissing('goals', goalsArg)
            it / node
        }
    }

    /**
     * Specifies the JVM options needed when launching Maven as an external process.
     * @param mavenOptsArg JVM options needed when launching Maven
     */
    def mavenOpts(String mavenOptsArg) {
        Preconditions.checkState(jobArguments['type'] == JobParent.maven, "mavenOpts can only be applied for Maven jobs")
        Preconditions.checkState(!mavenOptsAdded, "mavenOpts can only be applied once")
        mavenOptsAdded = true
        execute {
            def node = methodMissing('mavenOpts', mavenOptsArg)
            it / node
        }
    }

    /**
     * If set, Jenkins will send an e-mail notifications for each module, defaults to <code>true</code>.
     * @param perModuleEmailArg set to <code>false</code> to disable per module e-mail notifications
     */
    def perModuleEmail(boolean perModuleEmailArg) {
        Preconditions.checkState(jobArguments['type'] == JobParent.maven, "perModuleEmail can only be applied for Maven jobs")
        Preconditions.checkState(!perModuleEmailAdded, "perModuleEmail can only be applied once")
        perModuleEmailAdded = true
        execute {
            def node = methodMissing('perModuleEmail', perModuleEmailArg.toString())
            it / node
        }
    }

    /**
     * If set, Jenkins  will not automatically archive all artifacts generated by this project, defaults to
     * <code>false</code>.
     * @param archivingDisabledArg set to <code>true</code> to disable automatic archiving
     */
    def archivingDisabled(boolean archivingDisabledArg) {
        Preconditions.checkState(jobArguments['type'] == JobParent.maven, "archivingDisabled can only be applied for Maven jobs")
        Preconditions.checkState(!archivingDisabledAdded, "archivingDisabled can only be applied once")
        archivingDisabledAdded = true
        execute {
            def node = methodMissing('archivingDisabled', archivingDisabledArg.toString())
            it / node
        }
    }

    /**
     * Set to allow Jenkins to configure the build process in headless mode, defaults to <code>false</code>.
     * @param runHeadlessArg set to <code>true</code> to run the build process in headless mode
     */
    def runHeadless(boolean runHeadlessArg) {
        Preconditions.checkState(jobArguments['type'] == JobParent.maven, "runHeadless can only be applied for Maven jobs")
        Preconditions.checkState(!runHeadlessAdded, "runHeadless can only be applied once")
        runHeadlessAdded = true
        execute {
            def node = methodMissing('runHeadless', runHeadlessArg.toString())
            it / node
        }
    }

    /**
     * If checked, Jenkins will parse the POMs of this project, and see if any of its snapshot dependencies are built on
     * this Jenkins as well. If so, Jenkins will set up build dependency relationship so that whenever the dependency
     * job is built and a new SNAPSHOT jar is created, Jenkins will schedule a build of this project. Defaults to
     * <code>false</code>.
     * @param ignoreUpstreamChangesArg set to <code>true</code> to ignore SNAPSHOT dependencies
     */
    def ignoreUpstreamChanges(boolean ignoreUpstreamChangesArg) {
        Preconditions.checkState(jobArguments['type'] == JobParent.maven, "ignoreUpstreamChanges can only be applied for Maven jobs")
        Preconditions.checkState(!ignoreUpstreamChangesAdded, "ignoreUpstreamChanges can only be applied once")
        ignoreUpstreamChangesAdded = true
        execute {
            def node = methodMissing('ignoreUpstremChanges', ignoreUpstreamChangesArg.toString())
            it / node
        }
    }
}
